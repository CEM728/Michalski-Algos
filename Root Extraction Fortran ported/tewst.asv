clear;close all
f = 1e12;
omega = 2*pi*f;
lambda = 3e8/f;
num = 1e2; %Size of the arrays

% Example Validations

% Material Properties
ep1 = 1; % Air
ep2 = 9.7 ; % GaN/AlGaN layers combined
ep3 = 11; % Silicon base

% EM constants
mu0 = 4*pi*1e-7;
ep0 = 8.854e-12;

% Propagations Constants
k1 = omega*sqrt(mu0*ep0*ep1);
k2 = omega*sqrt(mu0*ep0*ep2);
k3 = omega*sqrt(mu0*ep0*ep3);


% Middle Layer thickness
d = .5*lambda;

% Source Location
zp = -d/2;

% Layer Heights
z0 = -d;
z1 = 0;
% point = -20.3 -20.7i;
% step = 40.6 + 41.4i;
point = 0 - k2*.01i;
step = 2*k3 + .02i*k2;
npts = 5012;
dnpts1 = npts - 1;
zstart = point;
zpoint_br = linspace(zstart, zstart + real(step), npts);
delta = real(step)/dnpts1;
zdelta_lower = delta;
% !
% !.... Right hand vertical side of rectangle
% !
% !     From
% !
% !       (point(1) + step(1) , point(2))
% !
% !     To
% !
% !       (point(1) + step(1), point(2) + step(2))
% !
zstart = point + real(step);
zpoint_ru = linspace(zstart, zstart + 1i*imag(step), npts);
delta = imag(step)/dnpts1;
zdelta_right = 1i*delta;
% !
% !.... Top side of rectangle
% !
% !     From
% !
% !       (point(1) + step(1) , point(2) + step(2))
% !
% !     To
% !
% !       (point(1) , point(2) + step(2))
% !
zstart = point + step;
zpoint_ul = linspace(zstart, point + 1i*imag(step), npts);
delta = -real(step)/dnpts1;
zdelta_upper = delta;
% !
% !.... Left-hand vertical side of rectangle back to an including the
% !     starting point
% !
% !     From
% !
% !       (point(1)  , point(2) + step(2))
% !
% !     To
% !
% !       (point(1) , point(2) )
% !
zstart = point + 1i*imag(step);
zpoint_lb = linspace(zstart, point, npts);
delta = -imag(step)/dnpts1;
zdelta_left = 1i*delta;

% Conctenate all of them
% Last points are common so delete them
zpoint = [zpoint_br(1:end), zpoint_ru(1:end-1), zpoint_ul(1:end-1), zpoint_lb(1:end-1)];
% !
% !---- Now compute the function and its argument all the way
% !     around the contour
% !
% !     Note that the arguments will normalized to the range
% !     [-pi, +pi] because of the behaviour of the ATAN2 function.
% !
F = FZ(zpoint);
real_F = real(F);
imag_F = imag(F);
arg_F = atan2(imag_F, real_F);
% !
% !---- Now try to count the transitions and bias the arguments
% !
% !     For example the function argument will jump from being
% !     nearly pi to being nearly -pi.
% !
% !     We assign to each point a "bias" index. We don't want to
% !     correct the arguments while we do this as it requires quite a
% !     lot of book keeping.
% !
% !     At the end, we then, process all arguments and bias them
% !     appropriately.
% !
jbias = 1;
% !
bias(1) = jbias;
% !
for i = 2 : (npts*4-3)
    % !
    % !
    % !....... There are two cases
    % !
    % !           1. Argument goes from +ve value near to pi to
    % !              a negative value near to pi.
    % !
    % !           2. Argument goes from -ve values near to pi to
    % !              a positive value near to pi.
    % !
    if ( arg_F(i-1) > pi/2  && (arg_F(i)   < -pi/2) )
        jbias = jbias + 1;
    elseif( arg_F(i-1) < -pi/2 && arg_F(i)   >  pi/2  )
        jbias = jbias - 1;
    end
    % !
    bias(i) = jbias;
end
% !
for i = 2 : (npts*4-3)
    arg_F(i) = arg_F(i) + real( (bias(i) - 1))*2*pi;
end

% !
% !---- Finally, compute the number of roots!
% !
delta  = ( arg_F(npts*4-3) - arg_F(1) ) / (2*pi);
% !
nroots = round(delta);   % Round off to nearest integer
s = zeros(1,2*nroots+1);
% !

% !
% !---- Check "nroots" for validity
% !
% !     Exit this routine
% !
% !         If 0
% !
% !         If nroots > maxroots (the dimensions are insufficient)
% !
% if(nroots .le. 0)        goto 800
% !
% if(nroots .gt. maxroots) goto 800

% !
% !=======================================================================
% !
% !     C O M P U T E   "S"   I N T E G R A L S
% !
% !=======================================================================
% !
% !---- We now perform the integrals "s" defined in the paper
% !
% !     We have two options, adaptive or fixed rule. These
% !     are implemented as two in-line subroutines to save
% !     even more call overhead. Both in-line routines return
% !     to line 700 on completion.
% !
% !     The fixed point scheme can re-use the computed function
% !     values used above. The adaptibe does not need them, so we
% !     can optimally free the memory at this point!
% !
% !
% !=======================================================================
% !
% !     T R A P E Z O I D A L    I N T E G R A T I O N
% !
% !=======================================================================
% !
% !
% !---- Let's do the integral "s_0" around the contour
% !
zone = 1;
% !
% !....... Along lower side of rectangle
% !
zlower = 0.5*( zone/F(1) + zone/F(npts) );

for  i = 2 : npts-1
    zlower = zlower + zone/F(i);
end
% !
zlower = zlower * zdelta_lower;
% !
% !....... Along right hand vertical side of rectangle
% !
zright = 0.5*( zone/F(npts) + zone/F(2*npts-1) );
% !
for i = npts+1 :  2*npts-2
    zright = zright + zone/F(i);
end

zright = zright * zdelta_right;
% !
% !....... Along upper side of rectangle
% !
zupper = 0.5*( zone/F(2*npts-1) + zone/F(3*npts-2) );
% !
for i = (2*npts - 1 + 1) : (3*npts - 2 - 1)
    zupper = zupper + zone/F(i);
end

zupper = zupper * zdelta_upper;
% !
% !....... Along left-hand vertical side of rectangle
% !
zleft = 0.5*( zone/F(3*npts-2) + zone/F(4*npts-3) );
% !
for i = (3*npts-2+1) : (4*npts-3-1)
    zleft = zleft + zone/F(i);
end
% !
zleft = zleft * zdelta_left;
% !
% !....... Combine all four sides into one integral now
% !
% !
s(1) = zlower + zright + zupper + zleft;
% !
s(1) = s(1) / (2i*pi);

%  !
%  !---- Let's do the integrals "s_p" around the contour
%  !
for np = 1 : 2 * nroots
    %  !
    %  !....... Along lower side of rectangle
    %  !
    zlower = 0.5*( ( (zpoint(1)^np)*(zone/F(1))       ) + ...
        ( (zpoint(npts)^np)*(zone/F(npts)) ));
    
    for i = 2  : npts - 1
        zlower = zlower + ( (zpoint(i)^np)*(zone/F(i)) );
    end
    %  !
    zlower = zlower * zdelta_lower;
    %  !
    %  !....... Along right hand vertical side of rectangle
    %  !
    zright = 0.5*( ( (zpoint(npts)^np)*(zone/F(npts))         ) +  ...
        ( (zpoint(2*npts-1)^np)*(zone/F(2*npts-1)) )    ...
        );
    %  !
    for i = npts + 1 : 2*npts-2
        zright = zright + ( (zpoint(i)^np)*(zone/F(i)) );
    end
    %  !
    zright = zright * zdelta_right;
    %  !
    %  !....... Along upper side of rectangle
    %  !
    zupper = 0.5*( ( (zpoint(2*npts-1)^np)*(zone/F(2*npts-1)) ) + ...
        ( (zpoint(3*npts-2)^np)*(zone/F(3*npts-2)) )   ...
        );
    %  !
    for  i = (2*npts - 1 + 1) : (3*npts - 2 - 1)
        zupper = zupper + ( (zpoint(i)^np)*(zone/F(i)) );
    end
    
    zupper = zupper * zdelta_upper;
    %  !
    %  !....... Along left-hand vertical side of rectangle
    %  !
    zleft = 0.5*( ( (zpoint(3*npts-2)^np)*(zone/F(3*npts-2)) ) + ...
        ( (zpoint(4*npts-3)^np)*(zone/F(4*npts-3)) )   ...
        );
    %  !
    for i = (3*npts-2+1) : (4*npts-3-1)
        zleft = zleft + ( (zpoint(i)^np)*(zone/F(i)) ) ;
    end
    %  !
    zleft = zleft * zdelta_left;
    %  !
    %  !....... Combine all four sides into one integral now
    %  !
    s(np) = zlower + zright + zupper + zleft;
    %  !
    s(np) = s(np)/(2i*pi);
end